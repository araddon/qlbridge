// Code generated by protoc-gen-go. DO NOT EDIT.
// source: schema.proto

/*
Package schema is a generated protocol buffer package.

It is generated from these files:
	schema.proto

It has these top-level messages:
	TablePartition
	Partition
	TablePb
	FieldPb
	Index
*/
package schema

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Partition describes a range of data (in a Table).
// left-key is contained in this partition
// right key is not contained in this partition, in the next partition.
// So any value >= left-key, and < right-key is contained herein.
type TablePartition struct {
	Table      string       `protobuf:"bytes,1,opt,name=table" json:"table,omitempty"`
	Keys       []string     `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	Partitions []*Partition `protobuf:"bytes,3,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *TablePartition) Reset()                    { *m = TablePartition{} }
func (m *TablePartition) String() string            { return proto.CompactTextString(m) }
func (*TablePartition) ProtoMessage()               {}
func (*TablePartition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TablePartition) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TablePartition) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *TablePartition) GetPartitions() []*Partition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

// Partition describes a range of data
// the left-key is contained in this partition
// the right key is not contained in this partition, in the next one
type Partition struct {
	Id    string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Left  string `protobuf:"bytes,2,opt,name=left" json:"left,omitempty"`
	Right string `protobuf:"bytes,3,opt,name=right" json:"right,omitempty"`
}

func (m *Partition) Reset()                    { *m = Partition{} }
func (m *Partition) String() string            { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()               {}
func (*Partition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Partition) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Partition) GetLeft() string {
	if m != nil {
		return m.Left
	}
	return ""
}

func (m *Partition) GetRight() string {
	if m != nil {
		return m.Right
	}
	return ""
}

type TablePb struct {
	// Name of table lowercased
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of table (not lowercased)
	NameOriginal string `protobuf:"bytes,2,opt,name=nameOriginal" json:"nameOriginal,omitempty"`
	// some dbs are more hiearchical (table-column-family)
	Parent string `protobuf:"bytes,3,opt,name=parent" json:"parent,omitempty"`
	// Character set, default = utf8
	Charset uint32 `protobuf:"varint,4,opt,name=Charset" json:"Charset,omitempty"`
	// Partitions in this table, optional may be empty
	Partition *TablePartition `protobuf:"bytes,5,opt,name=partition" json:"partition,omitempty"`
	// Partition Count
	PartitionCt uint32 `protobuf:"varint,6,opt,name=PartitionCt" json:"PartitionCt,omitempty"`
	// List of indexes for this table
	Indexes []*Index `protobuf:"bytes,7,rep,name=indexes" json:"indexes,omitempty"`
	// context json bytes
	ContextJson []byte `protobuf:"bytes,8,opt,name=contextJson,proto3" json:"contextJson,omitempty"`
	// List of Fields, in order
	Fieldpbs []*FieldPb `protobuf:"bytes,9,rep,name=fieldpbs" json:"fieldpbs,omitempty"`
}

func (m *TablePb) Reset()                    { *m = TablePb{} }
func (m *TablePb) String() string            { return proto.CompactTextString(m) }
func (*TablePb) ProtoMessage()               {}
func (*TablePb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TablePb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TablePb) GetNameOriginal() string {
	if m != nil {
		return m.NameOriginal
	}
	return ""
}

func (m *TablePb) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *TablePb) GetCharset() uint32 {
	if m != nil {
		return m.Charset
	}
	return 0
}

func (m *TablePb) GetPartition() *TablePartition {
	if m != nil {
		return m.Partition
	}
	return nil
}

func (m *TablePb) GetPartitionCt() uint32 {
	if m != nil {
		return m.PartitionCt
	}
	return 0
}

func (m *TablePb) GetIndexes() []*Index {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TablePb) GetContextJson() []byte {
	if m != nil {
		return m.ContextJson
	}
	return nil
}

func (m *TablePb) GetFieldpbs() []*FieldPb {
	if m != nil {
		return m.Fieldpbs
	}
	return nil
}

type FieldPb struct {
	Name        string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description string   `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Key         string   `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	Extra       string   `protobuf:"bytes,4,opt,name=extra" json:"extra,omitempty"`
	Data        string   `protobuf:"bytes,5,opt,name=data" json:"data,omitempty"`
	Length      uint32   `protobuf:"varint,6,opt,name=length" json:"length,omitempty"`
	Type        uint32   `protobuf:"varint,7,opt,name=type" json:"type,omitempty"`
	NativeType  uint32   `protobuf:"varint,8,opt,name=nativeType" json:"nativeType,omitempty"`
	DefLength   uint64   `protobuf:"varint,9,opt,name=defLength" json:"defLength,omitempty"`
	DefVal      []byte   `protobuf:"bytes,11,opt,name=defVal,proto3" json:"defVal,omitempty"`
	Indexed     bool     `protobuf:"varint,13,opt,name=indexed" json:"indexed,omitempty"`
	NoNulls     bool     `protobuf:"varint,14,opt,name=noNulls" json:"noNulls,omitempty"`
	Collation   string   `protobuf:"bytes,15,opt,name=collation" json:"collation,omitempty"`
	Roles       []string `protobuf:"bytes,16,rep,name=roles" json:"roles,omitempty"`
	Indexes     []*Index `protobuf:"bytes,17,rep,name=indexes" json:"indexes,omitempty"`
	ContextJson []byte   `protobuf:"bytes,18,opt,name=contextJson,proto3" json:"contextJson,omitempty"`
}

func (m *FieldPb) Reset()                    { *m = FieldPb{} }
func (m *FieldPb) String() string            { return proto.CompactTextString(m) }
func (*FieldPb) ProtoMessage()               {}
func (*FieldPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FieldPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldPb) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FieldPb) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FieldPb) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

func (m *FieldPb) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *FieldPb) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *FieldPb) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FieldPb) GetNativeType() uint32 {
	if m != nil {
		return m.NativeType
	}
	return 0
}

func (m *FieldPb) GetDefLength() uint64 {
	if m != nil {
		return m.DefLength
	}
	return 0
}

func (m *FieldPb) GetDefVal() []byte {
	if m != nil {
		return m.DefVal
	}
	return nil
}

func (m *FieldPb) GetIndexed() bool {
	if m != nil {
		return m.Indexed
	}
	return false
}

func (m *FieldPb) GetNoNulls() bool {
	if m != nil {
		return m.NoNulls
	}
	return false
}

func (m *FieldPb) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *FieldPb) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *FieldPb) GetIndexes() []*Index {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *FieldPb) GetContextJson() []byte {
	if m != nil {
		return m.ContextJson
	}
	return nil
}

// Index a description of how field(s) should be indexed for a table.
type Index struct {
	Name          string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Fields        []string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
	PrimaryKey    bool     `protobuf:"varint,3,opt,name=primaryKey" json:"primaryKey,omitempty"`
	HashPartition []string `protobuf:"bytes,4,rep,name=hashPartition" json:"hashPartition,omitempty"`
	PartitionSize int32    `protobuf:"varint,5,opt,name=partitionSize" json:"partitionSize,omitempty"`
}

func (m *Index) Reset()                    { *m = Index{} }
func (m *Index) String() string            { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()               {}
func (*Index) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Index) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Index) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Index) GetPrimaryKey() bool {
	if m != nil {
		return m.PrimaryKey
	}
	return false
}

func (m *Index) GetHashPartition() []string {
	if m != nil {
		return m.HashPartition
	}
	return nil
}

func (m *Index) GetPartitionSize() int32 {
	if m != nil {
		return m.PartitionSize
	}
	return 0
}

func init() {
	proto.RegisterType((*TablePartition)(nil), "schema.TablePartition")
	proto.RegisterType((*Partition)(nil), "schema.Partition")
	proto.RegisterType((*TablePb)(nil), "schema.TablePb")
	proto.RegisterType((*FieldPb)(nil), "schema.FieldPb")
	proto.RegisterType((*Index)(nil), "schema.Index")
}

func init() { proto.RegisterFile("schema.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x5b, 0x8a, 0xdb, 0x30,
	0x14, 0xc5, 0x71, 0x12, 0xc7, 0x37, 0x8f, 0x99, 0x11, 0x25, 0xe8, 0xa3, 0x14, 0x63, 0x0a, 0x35,
	0x14, 0x06, 0x3a, 0xed, 0x0e, 0x86, 0x16, 0xfa, 0xa0, 0x1d, 0xd4, 0xa1, 0xff, 0x72, 0xac, 0xc4,
	0x62, 0x14, 0xdb, 0x58, 0x6a, 0x49, 0xba, 0x99, 0x6e, 0xa1, 0x7b, 0xe8, 0xc6, 0x8a, 0xae, 0x25,
	0xc7, 0xa1, 0xf3, 0xd3, 0xaf, 0xdc, 0x73, 0x74, 0x75, 0xae, 0x74, 0x8e, 0x1c, 0x58, 0xe8, 0x4d,
	0x29, 0xf6, 0xfc, 0xba, 0x69, 0x6b, 0x53, 0x93, 0x69, 0x87, 0xd2, 0x3d, 0xac, 0xee, 0x79, 0xae,
	0xc4, 0x1d, 0x6f, 0x8d, 0x34, 0xb2, 0xae, 0xc8, 0x13, 0x98, 0x18, 0xcb, 0xd0, 0x20, 0x09, 0xb2,
	0x98, 0x75, 0x80, 0x10, 0x18, 0x3f, 0x88, 0xa3, 0xa6, 0xa3, 0x24, 0xcc, 0x62, 0x86, 0x35, 0x79,
	0x05, 0xd0, 0xf8, 0x6d, 0x9a, 0x86, 0x49, 0x98, 0xcd, 0x6f, 0xae, 0xae, 0xdd, 0x98, 0x5e, 0x90,
	0x0d, 0x9a, 0xd2, 0xb7, 0x10, 0x9f, 0x26, 0xad, 0x60, 0x24, 0x0b, 0x37, 0x66, 0x24, 0x0b, 0x3b,
	0x43, 0x89, 0xad, 0xa1, 0x23, 0x64, 0xb0, 0xb6, 0xa7, 0x69, 0xe5, 0xae, 0x34, 0x34, 0xec, 0x4e,
	0x83, 0x20, 0xfd, 0x33, 0x82, 0xa8, 0x3b, 0x76, 0x6e, 0x77, 0x55, 0x7c, 0xef, 0x8f, 0x8b, 0x35,
	0x49, 0x61, 0x61, 0x7f, 0xbf, 0xb4, 0x72, 0x27, 0x2b, 0xae, 0x9c, 0xe2, 0x19, 0x47, 0xd6, 0x30,
	0x6d, 0x78, 0x2b, 0x2a, 0x2f, 0xed, 0x10, 0xa1, 0x10, 0xdd, 0x96, 0xbc, 0xd5, 0xc2, 0xd0, 0x71,
	0x12, 0x64, 0x4b, 0xe6, 0x21, 0x79, 0x03, 0x71, 0x7f, 0x15, 0x3a, 0x49, 0x82, 0x6c, 0x7e, 0xb3,
	0xf6, 0xd7, 0x3d, 0x37, 0x91, 0x9d, 0x1a, 0x49, 0x02, 0xf3, 0x9e, 0xbf, 0x35, 0x74, 0x8a, 0x9a,
	0x43, 0x8a, 0xbc, 0x80, 0x48, 0x56, 0x85, 0x38, 0x08, 0x4d, 0x23, 0x34, 0x71, 0xe9, 0x55, 0xdf,
	0x5b, 0x9a, 0xf9, 0x55, 0x2b, 0xb5, 0xa9, 0x2b, 0x23, 0x0e, 0xe6, 0x83, 0xae, 0x2b, 0x3a, 0x4b,
	0x82, 0x6c, 0xc1, 0x86, 0x14, 0x79, 0x09, 0xb3, 0xad, 0x14, 0xaa, 0x68, 0x72, 0x4d, 0x63, 0xd4,
	0xba, 0xf0, 0x5a, 0xef, 0x2c, 0x7f, 0x97, 0xb3, 0xbe, 0x21, 0xfd, 0x1d, 0x42, 0xe4, 0xd8, 0x47,
	0x5d, 0x4c, 0x60, 0x5e, 0x08, 0xbd, 0x69, 0x65, 0x83, 0x37, 0xee, 0x4c, 0x1c, 0x52, 0xe4, 0x12,
	0xc2, 0x07, 0x71, 0x74, 0x06, 0xda, 0xd2, 0xe6, 0x25, 0x0e, 0xa6, 0xe5, 0xe8, 0x5d, 0xcc, 0x3a,
	0x60, 0xd5, 0x0b, 0x6e, 0x38, 0x9a, 0x16, 0x33, 0xac, 0xad, 0xff, 0x4a, 0x54, 0x3b, 0x53, 0x3a,
	0x4b, 0x1c, 0xb2, 0xbd, 0xe6, 0xd8, 0x08, 0x1a, 0x21, 0x8b, 0x35, 0x79, 0x06, 0x50, 0x71, 0x23,
	0x7f, 0x88, 0x7b, 0xbb, 0x32, 0xc3, 0x95, 0x01, 0x43, 0x9e, 0x42, 0x5c, 0x88, 0xed, 0xa7, 0x4e,
	0x2e, 0x4e, 0x82, 0x6c, 0xcc, 0x4e, 0x84, 0x9d, 0x54, 0x88, 0xed, 0x37, 0xae, 0xe8, 0x1c, 0x1d,
	0x73, 0xc8, 0x26, 0xdd, 0x39, 0x5b, 0xd0, 0x65, 0x12, 0x64, 0x33, 0x6f, 0x74, 0x61, 0x57, 0xaa,
	0xfa, 0xf3, 0x77, 0xa5, 0x34, 0x5d, 0x75, 0x2b, 0x0e, 0xda, 0x49, 0x9b, 0x5a, 0x29, 0x8e, 0x8e,
	0x5c, 0xe0, 0x75, 0x4e, 0x04, 0xbe, 0xd6, 0x5a, 0x09, 0x4d, 0x2f, 0xf1, 0x33, 0xe9, 0xc0, 0x30,
	0xdf, 0xab, 0xff, 0xc9, 0x97, 0xfc, 0x93, 0x6f, 0xfa, 0x2b, 0x80, 0x09, 0x6e, 0x7a, 0x34, 0xb0,
	0x35, 0x4c, 0x31, 0x5c, 0xff, 0x99, 0x3a, 0x64, 0xed, 0x6b, 0x5a, 0xb9, 0xe7, 0xed, 0xf1, 0xa3,
	0x4b, 0x6b, 0xc6, 0x06, 0x0c, 0x79, 0x0e, 0xcb, 0x92, 0xeb, 0xb2, 0x7f, 0x93, 0x74, 0x8c, 0xdb,
	0xcf, 0x49, 0xdb, 0xd5, 0xbf, 0xea, 0xaf, 0xf2, 0xa7, 0xc0, 0x34, 0x27, 0xec, 0x9c, 0xcc, 0xa7,
	0xf8, 0xff, 0xf2, 0xfa, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb8, 0x29, 0x27, 0x0d, 0x6f, 0x04,
	0x00, 0x00,
}
