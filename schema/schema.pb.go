// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema.proto

/*
	Package schema is a generated protocol buffer package.

	It is generated from these files:
		schema.proto

	It has these top-level messages:
		Command
		SchemaPb
		TablePartition
		Partition
		TablePb
		FieldPb
		Index
		ConfigSchema
		ConfigSource
		ConfigNode
*/
package schema

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Command_Operation int32

const (
	Command_Unknown   Command_Operation = 0
	Command_AddUpdate Command_Operation = 1
	Command_Drop      Command_Operation = 2
)

var Command_Operation_name = map[int32]string{
	0: "Unknown",
	1: "AddUpdate",
	2: "Drop",
}
var Command_Operation_value = map[string]int32{
	"Unknown":   0,
	"AddUpdate": 1,
	"Drop":      2,
}

func (x Command_Operation) String() string {
	return proto.EnumName(Command_Operation_name, int32(x))
}
func (Command_Operation) EnumDescriptor() ([]byte, []int) { return fileDescriptorSchema, []int{0, 0} }

// Command defines a Schema Replication command/message such as
// Drop, Alter, Create-Schema, etc.  Used to replicate schema changes
// across servers.
type Command struct {
	Op     Command_Operation `protobuf:"varint,1,opt,name=op,proto3,enum=schema.Command_Operation" json:"op,omitempty"`
	Origin string            `protobuf:"bytes,2,opt,name=origin,proto3" json:"origin,omitempty"`
	Schema string            `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Type   string            `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Index  uint64            `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
	Ts     int64             `protobuf:"varint,6,opt,name=ts,proto3" json:"ts,omitempty"`
	Msg    []byte            `protobuf:"bytes,7,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{0} }

func (m *Command) GetOp() Command_Operation {
	if m != nil {
		return m.Op
	}
	return Command_Unknown
}

func (m *Command) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

func (m *Command) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Command) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Command) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Command) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Command) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

// SchemaPb defines the fields that define schema attributes, and
// can be serialized.
type SchemaPb struct {
	// Name of schema lowercased
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Tables is map of tables
	Tables map[string]*TablePb `protobuf:"bytes,2,rep,name=tables" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// source configuration
	Conf *ConfigSource `protobuf:"bytes,3,opt,name=conf" json:"conf,omitempty"`
}

func (m *SchemaPb) Reset()                    { *m = SchemaPb{} }
func (m *SchemaPb) String() string            { return proto.CompactTextString(m) }
func (*SchemaPb) ProtoMessage()               {}
func (*SchemaPb) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{1} }

func (m *SchemaPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaPb) GetTables() map[string]*TablePb {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *SchemaPb) GetConf() *ConfigSource {
	if m != nil {
		return m.Conf
	}
	return nil
}

// Partition describes a range of data (in a Table).
// left-key is contained in this partition
// right key is not contained in this partition, in the next partition.
// So any value >= left-key, and < right-key is contained herein.
type TablePartition struct {
	Table      string       `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	Keys       []string     `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	Partitions []*Partition `protobuf:"bytes,3,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *TablePartition) Reset()                    { *m = TablePartition{} }
func (m *TablePartition) String() string            { return proto.CompactTextString(m) }
func (*TablePartition) ProtoMessage()               {}
func (*TablePartition) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{2} }

func (m *TablePartition) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TablePartition) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *TablePartition) GetPartitions() []*Partition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

// Partition describes a range of data
// the left-key is contained in this partition
// the right key is not contained in this partition, in the next one
type Partition struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Left  string `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right string `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (m *Partition) Reset()                    { *m = Partition{} }
func (m *Partition) String() string            { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()               {}
func (*Partition) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{3} }

func (m *Partition) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Partition) GetLeft() string {
	if m != nil {
		return m.Left
	}
	return ""
}

func (m *Partition) GetRight() string {
	if m != nil {
		return m.Right
	}
	return ""
}

// TablePb defines the fields that define table attributes, and
// can be serialized.
type TablePb struct {
	// Name of table lowercased
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name of table (not lowercased)
	NameOriginal string `protobuf:"bytes,2,opt,name=nameOriginal,proto3" json:"nameOriginal,omitempty"`
	// some dbs are more hiearchical (table-column-family)
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// Character set, default = utf8
	Charset uint32 `protobuf:"varint,4,opt,name=charset,proto3" json:"charset,omitempty"`
	// Partitions in this table, optional may be empty
	Partition *TablePartition `protobuf:"bytes,5,opt,name=partition" json:"partition,omitempty"`
	// Partition Count
	PartitionCt uint32 `protobuf:"varint,6,opt,name=PartitionCt,proto3" json:"PartitionCt,omitempty"`
	// List of indexes for this table
	Indexes []*Index `protobuf:"bytes,7,rep,name=indexes" json:"indexes,omitempty"`
	// context is additional arbitrary map values
	Context map[string]string `protobuf:"bytes,8,rep,name=context" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// List of Fields, in order
	Fieldpbs []*FieldPb `protobuf:"bytes,9,rep,name=fieldpbs" json:"fieldpbs,omitempty"`
}

func (m *TablePb) Reset()                    { *m = TablePb{} }
func (m *TablePb) String() string            { return proto.CompactTextString(m) }
func (*TablePb) ProtoMessage()               {}
func (*TablePb) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{4} }

func (m *TablePb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TablePb) GetNameOriginal() string {
	if m != nil {
		return m.NameOriginal
	}
	return ""
}

func (m *TablePb) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *TablePb) GetCharset() uint32 {
	if m != nil {
		return m.Charset
	}
	return 0
}

func (m *TablePb) GetPartition() *TablePartition {
	if m != nil {
		return m.Partition
	}
	return nil
}

func (m *TablePb) GetPartitionCt() uint32 {
	if m != nil {
		return m.PartitionCt
	}
	return 0
}

func (m *TablePb) GetIndexes() []*Index {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TablePb) GetContext() map[string]string {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *TablePb) GetFieldpbs() []*FieldPb {
	if m != nil {
		return m.Fieldpbs
	}
	return nil
}

// FieldPb defines attributes of a field/column that can
// be serialized and transported.
type FieldPb struct {
	Name        string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Key         string   `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Extra       string   `protobuf:"bytes,4,opt,name=extra,proto3" json:"extra,omitempty"`
	Data        string   `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	Length      uint32   `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
	Type        uint32   `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"`
	NativeType  uint32   `protobuf:"varint,8,opt,name=nativeType,proto3" json:"nativeType,omitempty"`
	DefLength   uint64   `protobuf:"varint,9,opt,name=defLength,proto3" json:"defLength,omitempty"`
	DefVal      []byte   `protobuf:"bytes,11,opt,name=defVal,proto3" json:"defVal,omitempty"`
	Indexed     bool     `protobuf:"varint,13,opt,name=indexed,proto3" json:"indexed,omitempty"`
	NoNulls     bool     `protobuf:"varint,14,opt,name=noNulls,proto3" json:"noNulls,omitempty"`
	Collation   string   `protobuf:"bytes,15,opt,name=collation,proto3" json:"collation,omitempty"`
	Roles       []string `protobuf:"bytes,16,rep,name=roles" json:"roles,omitempty"`
	Indexes     []*Index `protobuf:"bytes,17,rep,name=indexes" json:"indexes,omitempty"`
	// context is additional arbitrary map values
	Context  map[string]string `protobuf:"bytes,18,rep,name=context" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Position uint64            `protobuf:"varint,19,opt,name=position,proto3" json:"position,omitempty"`
}

func (m *FieldPb) Reset()                    { *m = FieldPb{} }
func (m *FieldPb) String() string            { return proto.CompactTextString(m) }
func (*FieldPb) ProtoMessage()               {}
func (*FieldPb) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{5} }

func (m *FieldPb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldPb) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FieldPb) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FieldPb) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

func (m *FieldPb) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *FieldPb) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *FieldPb) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FieldPb) GetNativeType() uint32 {
	if m != nil {
		return m.NativeType
	}
	return 0
}

func (m *FieldPb) GetDefLength() uint64 {
	if m != nil {
		return m.DefLength
	}
	return 0
}

func (m *FieldPb) GetDefVal() []byte {
	if m != nil {
		return m.DefVal
	}
	return nil
}

func (m *FieldPb) GetIndexed() bool {
	if m != nil {
		return m.Indexed
	}
	return false
}

func (m *FieldPb) GetNoNulls() bool {
	if m != nil {
		return m.NoNulls
	}
	return false
}

func (m *FieldPb) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *FieldPb) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *FieldPb) GetIndexes() []*Index {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *FieldPb) GetContext() map[string]string {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *FieldPb) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

// Index a description of how field(s) should be indexed for a table.
type Index struct {
	Name          string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Fields        []string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty"`
	PrimaryKey    bool     `protobuf:"varint,3,opt,name=primaryKey,proto3" json:"primaryKey,omitempty"`
	HashPartition []string `protobuf:"bytes,4,rep,name=hashPartition" json:"hashPartition,omitempty"`
	PartitionSize int32    `protobuf:"varint,5,opt,name=partitionSize,proto3" json:"partitionSize,omitempty"`
}

func (m *Index) Reset()                    { *m = Index{} }
func (m *Index) String() string            { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()               {}
func (*Index) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{6} }

func (m *Index) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Index) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Index) GetPrimaryKey() bool {
	if m != nil {
		return m.PrimaryKey
	}
	return false
}

func (m *Index) GetHashPartition() []string {
	if m != nil {
		return m.HashPartition
	}
	return nil
}

func (m *Index) GetPartitionSize() int32 {
	if m != nil {
		return m.PartitionSize
	}
	return 0
}

// ConfigSchema is the config block for Schema, the data-sources
// that make up this Virtual Schema.  Must have a name and list
// of sources to include.
type ConfigSchema struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources" json:"sources,omitempty"`
}

func (m *ConfigSchema) Reset()                    { *m = ConfigSchema{} }
func (m *ConfigSchema) String() string            { return proto.CompactTextString(m) }
func (*ConfigSchema) ProtoMessage()               {}
func (*ConfigSchema) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{7} }

func (m *ConfigSchema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigSchema) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

// ConfigSource are backend datasources ie : storage/database/csvfiles
// Each represents a single source type/config.  May belong to more
// than one schema.
type ConfigSource struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Schema string `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	Type   string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// TablesToLoad If not all tables from are going to be loaded.
	TablesToLoad []string `protobuf:"bytes,4,rep,name=TablesToLoad" json:"tables_to_load"`
	// convert underlying table names to friendly ones
	TableAliases map[string]string `protobuf:"bytes,5,rep,name=tableAliases" json:"table_aliases" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Hosts        []string          `protobuf:"bytes,7,rep,name=hosts" json:"hosts,omitempty"`
	Settings     map[string]string `protobuf:"bytes,8,rep,name=settings" json:"settings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Partitions   []*TablePartition `protobuf:"bytes,9,rep,name=partitions" json:"partitions,omitempty"`
	PartitionCt  uint32            `protobuf:"varint,10,opt,name=partitionCt,proto3" json:"partition_count"`
}

func (m *ConfigSource) Reset()                    { *m = ConfigSource{} }
func (m *ConfigSource) String() string            { return proto.CompactTextString(m) }
func (*ConfigSource) ProtoMessage()               {}
func (*ConfigSource) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{8} }

func (m *ConfigSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigSource) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *ConfigSource) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConfigSource) GetTablesToLoad() []string {
	if m != nil {
		return m.TablesToLoad
	}
	return nil
}

func (m *ConfigSource) GetTableAliases() map[string]string {
	if m != nil {
		return m.TableAliases
	}
	return nil
}

func (m *ConfigSource) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *ConfigSource) GetSettings() map[string]string {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *ConfigSource) GetPartitions() []*TablePartition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *ConfigSource) GetPartitionCt() uint32 {
	if m != nil {
		return m.PartitionCt
	}
	return 0
}

// ConfigNode are Servers/Services, ie a running instance of said Source
// - each must represent a single source type
// - normal use is a server, describing partitions of servers
// - may have arbitrary config info in Settings.
type ConfigNode struct {
	Name    string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Source  string            `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Address string            `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Context map[string]string `protobuf:"bytes,4,rep,name=context" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ConfigNode) Reset()                    { *m = ConfigNode{} }
func (m *ConfigNode) String() string            { return proto.CompactTextString(m) }
func (*ConfigNode) ProtoMessage()               {}
func (*ConfigNode) Descriptor() ([]byte, []int) { return fileDescriptorSchema, []int{9} }

func (m *ConfigNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigNode) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *ConfigNode) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ConfigNode) GetContext() map[string]string {
	if m != nil {
		return m.Context
	}
	return nil
}

func init() {
	proto.RegisterType((*Command)(nil), "schema.Command")
	proto.RegisterType((*SchemaPb)(nil), "schema.SchemaPb")
	proto.RegisterType((*TablePartition)(nil), "schema.TablePartition")
	proto.RegisterType((*Partition)(nil), "schema.Partition")
	proto.RegisterType((*TablePb)(nil), "schema.TablePb")
	proto.RegisterType((*FieldPb)(nil), "schema.FieldPb")
	proto.RegisterType((*Index)(nil), "schema.Index")
	proto.RegisterType((*ConfigSchema)(nil), "schema.ConfigSchema")
	proto.RegisterType((*ConfigSource)(nil), "schema.ConfigSource")
	proto.RegisterType((*ConfigNode)(nil), "schema.ConfigNode")
	proto.RegisterEnum("schema.Command_Operation", Command_Operation_name, Command_Operation_value)
}
func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Op))
	}
	if len(m.Origin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Origin)))
		i += copy(dAtA[i:], m.Origin)
	}
	if len(m.Schema) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Index != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Index))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Ts))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *SchemaPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaPb) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Tables) > 0 {
		for k, _ := range m.Tables {
			dAtA[i] = 0x12
			i++
			v := m.Tables[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSchema(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSchema(uint64(len(k))) + msgSize
			i = encodeVarintSchema(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSchema(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.Conf != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Conf.Size()))
		n2, err := m.Conf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *TablePartition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TablePartition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Partitions) > 0 {
		for _, msg := range m.Partitions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Partition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Partition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Left) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Left)))
		i += copy(dAtA[i:], m.Left)
	}
	if len(m.Right) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Right)))
		i += copy(dAtA[i:], m.Right)
	}
	return i, nil
}

func (m *TablePb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TablePb) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.NameOriginal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.NameOriginal)))
		i += copy(dAtA[i:], m.NameOriginal)
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if m.Charset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Charset))
	}
	if m.Partition != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Partition.Size()))
		n3, err := m.Partition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PartitionCt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.PartitionCt))
	}
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Context) > 0 {
		for k, _ := range m.Context {
			dAtA[i] = 0x42
			i++
			v := m.Context[k]
			mapSize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			i = encodeVarintSchema(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Fieldpbs) > 0 {
		for _, msg := range m.Fieldpbs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FieldPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldPb) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Extra) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Extra)))
		i += copy(dAtA[i:], m.Extra)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Length != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Length))
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Type))
	}
	if m.NativeType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.NativeType))
	}
	if m.DefLength != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.DefLength))
	}
	if len(m.DefVal) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.DefVal)))
		i += copy(dAtA[i:], m.DefVal)
	}
	if m.Indexed {
		dAtA[i] = 0x68
		i++
		if m.Indexed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoNulls {
		dAtA[i] = 0x70
		i++
		if m.NoNulls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Collation) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Collation)))
		i += copy(dAtA[i:], m.Collation)
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Context) > 0 {
		for k, _ := range m.Context {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			v := m.Context[k]
			mapSize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			i = encodeVarintSchema(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Position != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.Position))
	}
	return i, nil
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PrimaryKey {
		dAtA[i] = 0x18
		i++
		if m.PrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.HashPartition) > 0 {
		for _, s := range m.HashPartition {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PartitionSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.PartitionSize))
	}
	return i, nil
}

func (m *ConfigSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ConfigSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Schema) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.TablesToLoad) > 0 {
		for _, s := range m.TablesToLoad {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TableAliases) > 0 {
		for k, _ := range m.TableAliases {
			dAtA[i] = 0x2a
			i++
			v := m.TableAliases[k]
			mapSize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			i = encodeVarintSchema(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Settings) > 0 {
		for k, _ := range m.Settings {
			dAtA[i] = 0x42
			i++
			v := m.Settings[k]
			mapSize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			i = encodeVarintSchema(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Partitions) > 0 {
		for _, msg := range m.Partitions {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintSchema(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PartitionCt != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintSchema(dAtA, i, uint64(m.PartitionCt))
	}
	return i, nil
}

func (m *ConfigNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSchema(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Context) > 0 {
		for k, _ := range m.Context {
			dAtA[i] = 0x22
			i++
			v := m.Context[k]
			mapSize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			i = encodeVarintSchema(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSchema(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func encodeVarintSchema(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Command) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovSchema(uint64(m.Op))
	}
	l = len(m.Origin)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovSchema(uint64(m.Index))
	}
	if m.Ts != 0 {
		n += 1 + sovSchema(uint64(m.Ts))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	return n
}

func (m *SchemaPb) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSchema(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSchema(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSchema(uint64(mapEntrySize))
		}
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovSchema(uint64(l))
	}
	return n
}

func (m *TablePartition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	return n
}

func (m *Partition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Left)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Right)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	return n
}

func (m *TablePb) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.NameOriginal)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.Charset != 0 {
		n += 1 + sovSchema(uint64(m.Charset))
	}
	if m.Partition != nil {
		l = m.Partition.Size()
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.PartitionCt != 0 {
		n += 1 + sovSchema(uint64(m.PartitionCt))
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Context) > 0 {
		for k, v := range m.Context {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchema(uint64(mapEntrySize))
		}
	}
	if len(m.Fieldpbs) > 0 {
		for _, e := range m.Fieldpbs {
			l = e.Size()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	return n
}

func (m *FieldPb) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovSchema(uint64(m.Length))
	}
	if m.Type != 0 {
		n += 1 + sovSchema(uint64(m.Type))
	}
	if m.NativeType != 0 {
		n += 1 + sovSchema(uint64(m.NativeType))
	}
	if m.DefLength != 0 {
		n += 1 + sovSchema(uint64(m.DefLength))
	}
	l = len(m.DefVal)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if m.Indexed {
		n += 2
	}
	if m.NoNulls {
		n += 2
	}
	l = len(m.Collation)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 2 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 2 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Context) > 0 {
		for k, v := range m.Context {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			n += mapEntrySize + 2 + sovSchema(uint64(mapEntrySize))
		}
	}
	if m.Position != 0 {
		n += 2 + sovSchema(uint64(m.Position))
	}
	return n
}

func (m *Index) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if m.PrimaryKey {
		n += 2
	}
	if len(m.HashPartition) > 0 {
		for _, s := range m.HashPartition {
			l = len(s)
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if m.PartitionSize != 0 {
		n += 1 + sovSchema(uint64(m.PartitionSize))
	}
	return n
}

func (m *ConfigSchema) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	return n
}

func (m *ConfigSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.TablesToLoad) > 0 {
		for _, s := range m.TablesToLoad {
			l = len(s)
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.TableAliases) > 0 {
		for k, v := range m.TableAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchema(uint64(mapEntrySize))
		}
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if len(m.Settings) > 0 {
		for k, v := range m.Settings {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchema(uint64(mapEntrySize))
		}
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovSchema(uint64(l))
		}
	}
	if m.PartitionCt != 0 {
		n += 1 + sovSchema(uint64(m.PartitionCt))
	}
	return n
}

func (m *ConfigNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSchema(uint64(l))
	}
	if len(m.Context) > 0 {
		for k, v := range m.Context {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchema(uint64(len(k))) + 1 + len(v) + sovSchema(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchema(uint64(mapEntrySize))
		}
	}
	return n
}

func sovSchema(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSchema(x uint64) (n int) {
	return sovSchema(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Command_Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[string]*TablePb)
			}
			var mapkey string
			var mapvalue *TablePb
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSchema
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSchema
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TablePb{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchema(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSchema
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &ConfigSource{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TablePartition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TablePartition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TablePartition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &Partition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Partition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Partition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Partition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Left = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Right = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TablePb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TablePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TablePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameOriginal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameOriginal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			m.Charset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Charset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partition == nil {
				m.Partition = &TablePartition{}
			}
			if err := m.Partition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionCt", wireType)
			}
			m.PartitionCt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionCt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &Index{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchema(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSchema
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Context[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fieldpbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fieldpbs = append(m.Fieldpbs, &FieldPb{})
			if err := m.Fieldpbs[len(m.Fieldpbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeType", wireType)
			}
			m.NativeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NativeType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefLength", wireType)
			}
			m.DefLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefLength |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefVal = append(m.DefVal[:0], dAtA[iNdEx:postIndex]...)
			if m.DefVal == nil {
				m.DefVal = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Indexed = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoNulls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoNulls = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &Index{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchema(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSchema
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Context[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimaryKey = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashPartition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashPartition = append(m.HashPartition, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSize", wireType)
			}
			m.PartitionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesToLoad", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TablesToLoad = append(m.TablesToLoad, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableAliases == nil {
				m.TableAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchema(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSchema
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchema(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSchema
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Settings[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &TablePartition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionCt", wireType)
			}
			m.PartitionCt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionCt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchema
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchema
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchema
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchema(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSchema
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Context[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchema(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchema
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchema(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchema
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchema
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSchema
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSchema
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSchema(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSchema = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchema   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("schema.proto", fileDescriptorSchema) }

var fileDescriptorSchema = []byte{
	// 1088 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xee, 0xfa, 0x6f, 0xbd, 0xc7, 0x3f, 0x71, 0xa6, 0x51, 0xb4, 0x58, 0x55, 0x62, 0x59, 0xfc,
	0x18, 0x21, 0x52, 0x35, 0x94, 0x08, 0x0a, 0x02, 0x35, 0xa5, 0x48, 0x40, 0xd5, 0x46, 0x93, 0x94,
	0x3b, 0x14, 0x8d, 0xbd, 0x63, 0x7b, 0x95, 0xf5, 0xce, 0x6a, 0x67, 0x5c, 0x12, 0xde, 0x03, 0x89,
	0x2b, 0xb8, 0xe5, 0x51, 0x80, 0x2b, 0x9e, 0x20, 0x42, 0xe9, 0x5d, 0x9e, 0x02, 0xcd, 0x99, 0xd9,
	0xf5, 0xae, 0xea, 0x48, 0xad, 0x7a, 0xe5, 0x39, 0xdf, 0xf9, 0x9b, 0x73, 0xce, 0x37, 0x67, 0x0d,
	0x6d, 0x39, 0x99, 0xf3, 0x05, 0xdb, 0x4b, 0x52, 0xa1, 0x04, 0x69, 0x18, 0xa9, 0xff, 0xf1, 0x2c,
	0x54, 0xf3, 0xe5, 0x78, 0x6f, 0x22, 0x16, 0x77, 0x67, 0x62, 0x26, 0xee, 0xa2, 0x7a, 0xbc, 0x9c,
	0xa2, 0x84, 0x02, 0x9e, 0x8c, 0xdb, 0xf0, 0xa5, 0x03, 0xee, 0x23, 0xb1, 0x58, 0xb0, 0x38, 0x20,
	0x1f, 0x42, 0x45, 0x24, 0xbe, 0x33, 0x70, 0x46, 0xdd, 0xfd, 0x77, 0xf6, 0x6c, 0x74, 0xab, 0xdc,
	0x7b, 0x96, 0xf0, 0x94, 0xa9, 0x50, 0xc4, 0xb4, 0x22, 0x12, 0xb2, 0x0d, 0x0d, 0x91, 0x86, 0xb3,
	0x30, 0xf6, 0x2b, 0x03, 0x67, 0xe4, 0x51, 0x2b, 0x69, 0xdc, 0xf8, 0xf9, 0x55, 0x83, 0x1b, 0x89,
	0x10, 0xa8, 0xa9, 0x8b, 0x84, 0xfb, 0x35, 0x44, 0xf1, 0x4c, 0xb6, 0xa0, 0x1e, 0xc6, 0x01, 0x3f,
	0xf7, 0xeb, 0x03, 0x67, 0x54, 0xa3, 0x46, 0x20, 0x5d, 0xa8, 0x28, 0xe9, 0x37, 0x06, 0xce, 0xa8,
	0x4a, 0x2b, 0x4a, 0x92, 0x1e, 0x54, 0x17, 0x72, 0xe6, 0xbb, 0x03, 0x67, 0xd4, 0xa6, 0xfa, 0x38,
	0xbc, 0x07, 0x5e, 0x7e, 0x19, 0xd2, 0x02, 0xf7, 0x79, 0x7c, 0x16, 0x8b, 0x9f, 0xe3, 0xde, 0x2d,
	0xd2, 0x01, 0xef, 0x61, 0x10, 0x3c, 0x4f, 0x02, 0xa6, 0x78, 0xcf, 0x21, 0x4d, 0xa8, 0x7d, 0x93,
	0x8a, 0xa4, 0x57, 0x19, 0xfe, 0xe3, 0x40, 0xf3, 0x18, 0x6f, 0x72, 0x34, 0xd6, 0x77, 0x89, 0xd9,
	0x82, 0x63, 0xa1, 0x1e, 0xc5, 0x33, 0xb9, 0x0f, 0x0d, 0xc5, 0xc6, 0x11, 0x97, 0x7e, 0x65, 0x50,
	0x1d, 0xb5, 0xf6, 0xef, 0x64, 0xe5, 0x67, 0x5e, 0x7b, 0x27, 0xa8, 0x7e, 0x1c, 0xab, 0xf4, 0x82,
	0x5a, 0x5b, 0x32, 0x82, 0xda, 0x44, 0xc4, 0x53, 0xac, 0xb5, 0xb5, 0xbf, 0xb5, 0x6a, 0x59, 0x3c,
	0x0d, 0x67, 0xc7, 0x62, 0x99, 0x4e, 0x38, 0x45, 0x8b, 0xfe, 0xf7, 0xd0, 0x2a, 0x04, 0xd0, 0x45,
	0x9d, 0xf1, 0x0b, 0x7b, 0x03, 0x7d, 0x24, 0xef, 0x41, 0xfd, 0x05, 0x8b, 0x96, 0x1c, 0xfb, 0xd9,
	0xda, 0xdf, 0xc8, 0x62, 0xa1, 0xd7, 0xd1, 0x98, 0x1a, 0xed, 0x83, 0xca, 0x67, 0xce, 0x70, 0x01,
	0x5d, 0x83, 0xb2, 0x54, 0x85, 0xd8, 0x84, 0x2d, 0xa8, 0xe3, 0x8d, 0x6c, 0x40, 0x23, 0xe8, 0x3a,
	0xcf, 0xf8, 0x85, 0xa9, 0xc8, 0xa3, 0x78, 0x26, 0xf7, 0x00, 0x92, 0xcc, 0x4d, 0xfa, 0x55, 0xac,
	0x75, 0x33, 0xcb, 0x95, 0x07, 0xa4, 0x05, 0xa3, 0xe1, 0x63, 0xf0, 0x56, 0x99, 0xba, 0x50, 0x09,
	0x03, 0x9b, 0xa6, 0x12, 0x06, 0x3a, 0x47, 0xc4, 0xa7, 0xca, 0xb2, 0x00, 0xcf, 0xfa, 0x36, 0x69,
	0x38, 0x9b, 0x2b, 0x4b, 0x01, 0x23, 0x0c, 0x7f, 0xad, 0x82, 0x6b, 0x8b, 0x59, 0x3b, 0x81, 0x21,
	0xb4, 0xf5, 0xef, 0x33, 0xe4, 0x11, 0x8b, 0x6c, 0xc4, 0x12, 0xa6, 0xd9, 0x95, 0xb0, 0x94, 0xc7,
	0x59, 0x68, 0x2b, 0x11, 0x1f, 0xdc, 0xc9, 0x9c, 0xa5, 0x92, 0x2b, 0x24, 0x58, 0x87, 0x66, 0x22,
	0xb9, 0x0f, 0x5e, 0x5e, 0x0a, 0xf2, 0xac, 0xb5, 0xbf, 0x5d, 0x6e, 0x6d, 0x5e, 0xf3, 0xca, 0x90,
	0x0c, 0xa0, 0x95, 0xe3, 0x8f, 0x14, 0x92, 0xb1, 0x43, 0x8b, 0x10, 0xf9, 0x00, 0x5c, 0xa4, 0x2b,
	0x97, 0xbe, 0x8b, 0x4d, 0xec, 0x64, 0x51, 0xbf, 0xd3, 0x30, 0xcd, 0xb4, 0xe4, 0x00, 0xdc, 0x89,
	0x88, 0x15, 0x3f, 0x57, 0x7e, 0xb3, 0xcc, 0x2c, 0xdb, 0x0c, 0xcd, 0x16, 0xad, 0x36, 0xcc, 0xca,
	0x8c, 0xc9, 0x47, 0xd0, 0x9c, 0x86, 0x3c, 0x0a, 0x92, 0xb1, 0xf4, 0x3d, 0x74, 0xcc, 0x29, 0xf1,
	0xad, 0xc6, 0x8f, 0xc6, 0x34, 0x37, 0xe8, 0x3f, 0x80, 0x76, 0x31, 0xca, 0x1a, 0x7a, 0x6d, 0x15,
	0xe9, 0xe5, 0x15, 0xd9, 0xf4, 0x7b, 0x0d, 0x5c, 0x1b, 0x71, 0xed, 0x5c, 0x06, 0xd0, 0x0a, 0xb8,
	0x9c, 0xa4, 0x61, 0x82, 0x3d, 0x34, 0xfe, 0x45, 0x28, 0xcb, 0x56, 0x2d, 0x65, 0xe3, 0xe7, 0x2a,
	0x65, 0xf6, 0xb9, 0x1b, 0x41, 0x47, 0x0f, 0x98, 0x62, 0x38, 0x06, 0x8f, 0xe2, 0x59, 0x4f, 0x34,
	0xe2, 0xf1, 0x4c, 0xcd, 0x6d, 0x93, 0xad, 0x94, 0xef, 0x0b, 0x17, 0x51, 0xb3, 0x2f, 0x76, 0x00,
	0x62, 0xa6, 0xc2, 0x17, 0xfc, 0x44, 0x6b, 0x9a, 0xa8, 0x29, 0x20, 0xe4, 0x0e, 0x78, 0x01, 0x9f,
	0x3e, 0x31, 0xe1, 0x3c, 0xdc, 0x29, 0x2b, 0x40, 0x67, 0x0a, 0xf8, 0xf4, 0x47, 0x16, 0xf9, 0x2d,
	0x5c, 0x25, 0x56, 0xd2, 0xdc, 0x31, 0xb3, 0x0a, 0xfc, 0xce, 0xc0, 0x19, 0x35, 0xb3, 0xd1, 0x05,
	0x5a, 0x13, 0x8b, 0xa7, 0xcb, 0x28, 0x92, 0x7e, 0xd7, 0x68, 0xac, 0xa8, 0x33, 0x4d, 0x44, 0x14,
	0xe1, 0x06, 0xf2, 0x37, 0xb0, 0x9c, 0x15, 0x80, 0xfc, 0x17, 0x7a, 0x95, 0xf4, 0xf0, 0xe1, 0x19,
	0xa1, 0xc8, 0x98, 0xcd, 0xd7, 0x65, 0x0c, 0x29, 0x33, 0xc6, 0x8e, 0xe9, 0x06, 0xc6, 0xf4, 0xa1,
	0x99, 0x08, 0x69, 0x98, 0x7e, 0x1b, 0xab, 0xcf, 0xe5, 0xb7, 0x22, 0xc8, 0x1f, 0x0e, 0xd4, 0xf1,
	0x8a, 0x6b, 0xe9, 0xb1, 0x0d, 0x0d, 0xa4, 0x61, 0xb6, 0x66, 0xac, 0xa4, 0x87, 0x95, 0xa4, 0xe1,
	0x82, 0xa5, 0x17, 0x3f, 0x58, 0x6e, 0x34, 0x69, 0x01, 0x21, 0xef, 0x42, 0x67, 0xce, 0xe4, 0x3c,
	0x7f, 0x53, 0x7e, 0x0d, 0xdd, 0xcb, 0xa0, 0xb6, 0xca, 0x5f, 0xe5, 0x71, 0xf8, 0x0b, 0x47, 0xee,
	0xd4, 0x69, 0x19, 0x1c, 0x7e, 0x89, 0xd5, 0xe9, 0x95, 0x9b, 0x7f, 0x6c, 0x5e, 0xb9, 0xa7, 0x0f,
	0xae, 0xc4, 0x85, 0x9c, 0x5d, 0x34, 0x13, 0x87, 0x7f, 0xd6, 0x72, 0x77, 0x44, 0x6e, 0x2a, 0xd3,
	0x7e, 0xd7, 0x2a, 0x6b, 0xbf, 0x6b, 0xd5, 0xc2, 0x77, 0xed, 0x00, 0xda, 0x66, 0xd7, 0x9f, 0x88,
	0x27, 0x82, 0x05, 0xa6, 0xb2, 0x43, 0x72, 0x7d, 0xb9, 0xdb, 0x35, 0xdf, 0x8d, 0x53, 0x25, 0x4e,
	0x23, 0xc1, 0x02, 0x5a, 0xb2, 0x23, 0x3f, 0x41, 0x1b, 0xf5, 0x0f, 0xa3, 0x90, 0x49, 0x2e, 0xfd,
	0x3a, 0x4e, 0xff, 0xfd, 0x75, 0x5f, 0x15, 0xb3, 0x3c, 0xac, 0x21, 0x8e, 0xf4, 0x70, 0xf3, 0xfa,
	0x72, 0xb7, 0x83, 0xfe, 0xa7, 0xcc, 0xe0, 0xb4, 0x14, 0x4e, 0x4f, 0x78, 0x2e, 0xa4, 0x32, 0x0b,
	0xcb, 0xa3, 0x46, 0x20, 0x5f, 0x41, 0x53, 0x72, 0xa5, 0xc2, 0x78, 0x26, 0xed, 0x82, 0x1a, 0xae,
	0x4d, 0x78, 0x6c, 0x8d, 0x0c, 0xe9, 0x72, 0x1f, 0x72, 0x50, 0xfa, 0xa0, 0x98, 0x4d, 0x75, 0xd3,
	0x86, 0x2d, 0x58, 0x92, 0x4f, 0xa1, 0x95, 0x14, 0x56, 0x2c, 0xe8, 0xd7, 0x7c, 0x78, 0xfb, 0xfa,
	0x72, 0x77, 0x23, 0x87, 0x4f, 0x27, 0x62, 0x19, 0x2b, 0x5a, 0xb4, 0xeb, 0x7f, 0x0d, 0x9b, 0xaf,
	0x94, 0xfe, 0x26, 0x6c, 0xee, 0x7f, 0x01, 0x9d, 0x52, 0x29, 0x6f, 0xf4, 0x14, 0xfe, 0x76, 0x00,
	0x4c, 0x57, 0x9e, 0x8a, 0xe0, 0x66, 0xa2, 0x60, 0xc7, 0x72, 0xa2, 0x18, 0x52, 0xf9, 0xe0, 0xb2,
	0x20, 0x48, 0xb9, 0x94, 0x96, 0x2b, 0x99, 0x48, 0x3e, 0x5f, 0xbd, 0xf7, 0x1a, 0xb6, 0x6f, 0xb7,
	0x3c, 0x00, 0x9d, 0x6a, 0xfd, 0x93, 0x7f, 0x9b, 0x67, 0x7d, 0xd8, 0xfb, 0xeb, 0x6a, 0xc7, 0xf9,
	0xf7, 0x6a, 0xc7, 0xf9, 0xef, 0x6a, 0xc7, 0xf9, 0xed, 0xe5, 0xce, 0xad, 0x71, 0x03, 0xff, 0x11,
	0x7e, 0xf2, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfb, 0x55, 0xf8, 0x81, 0x58, 0x0a, 0x00, 0x00,
}
