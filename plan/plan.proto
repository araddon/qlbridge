syntax = "proto3";
package plan;

// protoc --proto_path=$GOPATH/src:. --go_out=. *.proto

import "github.com/araddon/qlbridge/rel/sql.proto";
import "github.com/araddon/qlbridge/expr/node.proto";
//import "github.com/araddon/qlbridge/schema/schema.proto";


// Plan must be exactly one type of plan
message PlanPb {
  bool                 parallel = 1;
  SelectPb               select = 3;
  SourcePb               source = 4;
  WherePb                 where = 5;
  HavingPb               having = 6;
  GroupByPb             groupBy = 7;
  OrderPb                 order = 8;
  JoinMergePb         joinMerge = 9;
  JoinKeyPb            joinKey = 10;
  rel.ProjectionPb  projection = 11;
  repeated PlanPb              children = 12;
}

// Select Plan 
message SelectPb {
	rel.SqlSelectPb    select = 1;
	ContextPb         context = 2;
}

// Context 
message ContextPb {
	string      schema = 1;
	uint64          id = 2;
	uint64 fingerprint = 3;
}

// Source Plan is a plan for single source of select query, of which
// many may exist (joins, sub-querys etc)
message SourcePb {
	// do we need group-by, join, partition key for routing purposes?
	bool needsHashableKey         = 2;
	// Is this final projection or not?  non finals are partial-sub-query types
	bool final                    = 3;
	// Is this plan complete as is?  skip remaining plan walk steps
	bool complete                 = 4;
	bool join                     = 5;
	bool sourceExec               = 6;
	bytes custom                  = 7;
	rel.SqlSourcePb sqlSource     = 8;
	rel.ProjectionPb projection   = 9;
}

// Where Plan 
message WherePb {
	rel.SqlSelectPb select = 1;
	bool            final  = 2;
}

// Group By Plan 
message GroupByPb {
	rel.SqlSelectPb   select = 1;
}

message HavingPb {
	rel.SqlSelectPb   select = 1;
}

message OrderPb {
	rel.SqlSelectPb   select = 1;
}

message JoinMergePb {
	expr.NodePb having = 1;
}

message JoinKeyPb {
	expr.NodePb having = 1;
}