// Code generated by protoc-gen-go. DO NOT EDIT.
// source: plan.proto

/*
Package plan is a generated protocol buffer package.

It is generated from these files:
	plan.proto

It has these top-level messages:
	PlanPb
	SelectPb
	ContextPb
	SourcePb
	WherePb
	GroupByPb
	HavingPb
	OrderPb
	JoinMergePb
	JoinKeyPb
*/
package plan

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import rel "github.com/araddon/qlbridge/rel"
import expr "github.com/araddon/qlbridge/expr"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Plan must be exactly one type of plan
type PlanPb struct {
	Parallel   bool              `protobuf:"varint,1,opt,name=parallel" json:"parallel,omitempty"`
	Select     *SelectPb         `protobuf:"bytes,3,opt,name=select" json:"select,omitempty"`
	Source     *SourcePb         `protobuf:"bytes,4,opt,name=source" json:"source,omitempty"`
	Where      *WherePb          `protobuf:"bytes,5,opt,name=where" json:"where,omitempty"`
	Having     *HavingPb         `protobuf:"bytes,6,opt,name=having" json:"having,omitempty"`
	GroupBy    *GroupByPb        `protobuf:"bytes,7,opt,name=groupBy" json:"groupBy,omitempty"`
	Order      *OrderPb          `protobuf:"bytes,8,opt,name=order" json:"order,omitempty"`
	JoinMerge  *JoinMergePb      `protobuf:"bytes,9,opt,name=joinMerge" json:"joinMerge,omitempty"`
	JoinKey    *JoinKeyPb        `protobuf:"bytes,10,opt,name=joinKey" json:"joinKey,omitempty"`
	Projection *rel.ProjectionPb `protobuf:"bytes,11,opt,name=projection" json:"projection,omitempty"`
	Children   []*PlanPb         `protobuf:"bytes,12,rep,name=children" json:"children,omitempty"`
}

func (m *PlanPb) Reset()                    { *m = PlanPb{} }
func (m *PlanPb) String() string            { return proto.CompactTextString(m) }
func (*PlanPb) ProtoMessage()               {}
func (*PlanPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PlanPb) GetParallel() bool {
	if m != nil {
		return m.Parallel
	}
	return false
}

func (m *PlanPb) GetSelect() *SelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

func (m *PlanPb) GetSource() *SourcePb {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *PlanPb) GetWhere() *WherePb {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *PlanPb) GetHaving() *HavingPb {
	if m != nil {
		return m.Having
	}
	return nil
}

func (m *PlanPb) GetGroupBy() *GroupByPb {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *PlanPb) GetOrder() *OrderPb {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *PlanPb) GetJoinMerge() *JoinMergePb {
	if m != nil {
		return m.JoinMerge
	}
	return nil
}

func (m *PlanPb) GetJoinKey() *JoinKeyPb {
	if m != nil {
		return m.JoinKey
	}
	return nil
}

func (m *PlanPb) GetProjection() *rel.ProjectionPb {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *PlanPb) GetChildren() []*PlanPb {
	if m != nil {
		return m.Children
	}
	return nil
}

// Select Plan
type SelectPb struct {
	Select  *rel.SqlSelectPb `protobuf:"bytes,1,opt,name=select" json:"select,omitempty"`
	Context *ContextPb       `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
}

func (m *SelectPb) Reset()                    { *m = SelectPb{} }
func (m *SelectPb) String() string            { return proto.CompactTextString(m) }
func (*SelectPb) ProtoMessage()               {}
func (*SelectPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SelectPb) GetSelect() *rel.SqlSelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

func (m *SelectPb) GetContext() *ContextPb {
	if m != nil {
		return m.Context
	}
	return nil
}

// Context
type ContextPb struct {
	Schema      string `protobuf:"bytes,1,opt,name=schema" json:"schema,omitempty"`
	Id          uint64 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Fingerprint uint64 `protobuf:"varint,3,opt,name=fingerprint" json:"fingerprint,omitempty"`
}

func (m *ContextPb) Reset()                    { *m = ContextPb{} }
func (m *ContextPb) String() string            { return proto.CompactTextString(m) }
func (*ContextPb) ProtoMessage()               {}
func (*ContextPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ContextPb) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *ContextPb) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ContextPb) GetFingerprint() uint64 {
	if m != nil {
		return m.Fingerprint
	}
	return 0
}

// Source Plan is a plan for single source of select query, of which
// many may exist (joins, sub-querys etc)
type SourcePb struct {
	// do we need group-by, join, partition key for routing purposes?
	NeedsHashableKey bool `protobuf:"varint,2,opt,name=needsHashableKey" json:"needsHashableKey,omitempty"`
	// Is this final projection or not?  non finals are partial-sub-query types
	Final bool `protobuf:"varint,3,opt,name=final" json:"final,omitempty"`
	// Is this plan complete as is?  skip remaining plan walk steps
	Complete   bool              `protobuf:"varint,4,opt,name=complete" json:"complete,omitempty"`
	Join       bool              `protobuf:"varint,5,opt,name=join" json:"join,omitempty"`
	SourceExec bool              `protobuf:"varint,6,opt,name=sourceExec" json:"sourceExec,omitempty"`
	Custom     []byte            `protobuf:"bytes,7,opt,name=custom,proto3" json:"custom,omitempty"`
	SqlSource  *rel.SqlSourcePb  `protobuf:"bytes,8,opt,name=sqlSource" json:"sqlSource,omitempty"`
	Projection *rel.ProjectionPb `protobuf:"bytes,9,opt,name=projection" json:"projection,omitempty"`
}

func (m *SourcePb) Reset()                    { *m = SourcePb{} }
func (m *SourcePb) String() string            { return proto.CompactTextString(m) }
func (*SourcePb) ProtoMessage()               {}
func (*SourcePb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SourcePb) GetNeedsHashableKey() bool {
	if m != nil {
		return m.NeedsHashableKey
	}
	return false
}

func (m *SourcePb) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *SourcePb) GetComplete() bool {
	if m != nil {
		return m.Complete
	}
	return false
}

func (m *SourcePb) GetJoin() bool {
	if m != nil {
		return m.Join
	}
	return false
}

func (m *SourcePb) GetSourceExec() bool {
	if m != nil {
		return m.SourceExec
	}
	return false
}

func (m *SourcePb) GetCustom() []byte {
	if m != nil {
		return m.Custom
	}
	return nil
}

func (m *SourcePb) GetSqlSource() *rel.SqlSourcePb {
	if m != nil {
		return m.SqlSource
	}
	return nil
}

func (m *SourcePb) GetProjection() *rel.ProjectionPb {
	if m != nil {
		return m.Projection
	}
	return nil
}

// Where Plan
type WherePb struct {
	Select *rel.SqlSelectPb `protobuf:"bytes,1,opt,name=select" json:"select,omitempty"`
	Final  bool             `protobuf:"varint,2,opt,name=final" json:"final,omitempty"`
}

func (m *WherePb) Reset()                    { *m = WherePb{} }
func (m *WherePb) String() string            { return proto.CompactTextString(m) }
func (*WherePb) ProtoMessage()               {}
func (*WherePb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *WherePb) GetSelect() *rel.SqlSelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

func (m *WherePb) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

// Group By Plan
type GroupByPb struct {
	Select *rel.SqlSelectPb `protobuf:"bytes,1,opt,name=select" json:"select,omitempty"`
}

func (m *GroupByPb) Reset()                    { *m = GroupByPb{} }
func (m *GroupByPb) String() string            { return proto.CompactTextString(m) }
func (*GroupByPb) ProtoMessage()               {}
func (*GroupByPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GroupByPb) GetSelect() *rel.SqlSelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

type HavingPb struct {
	Select *rel.SqlSelectPb `protobuf:"bytes,1,opt,name=select" json:"select,omitempty"`
}

func (m *HavingPb) Reset()                    { *m = HavingPb{} }
func (m *HavingPb) String() string            { return proto.CompactTextString(m) }
func (*HavingPb) ProtoMessage()               {}
func (*HavingPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *HavingPb) GetSelect() *rel.SqlSelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

type OrderPb struct {
	Select *rel.SqlSelectPb `protobuf:"bytes,1,opt,name=select" json:"select,omitempty"`
}

func (m *OrderPb) Reset()                    { *m = OrderPb{} }
func (m *OrderPb) String() string            { return proto.CompactTextString(m) }
func (*OrderPb) ProtoMessage()               {}
func (*OrderPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *OrderPb) GetSelect() *rel.SqlSelectPb {
	if m != nil {
		return m.Select
	}
	return nil
}

type JoinMergePb struct {
	Having *expr.NodePb `protobuf:"bytes,1,opt,name=having" json:"having,omitempty"`
}

func (m *JoinMergePb) Reset()                    { *m = JoinMergePb{} }
func (m *JoinMergePb) String() string            { return proto.CompactTextString(m) }
func (*JoinMergePb) ProtoMessage()               {}
func (*JoinMergePb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *JoinMergePb) GetHaving() *expr.NodePb {
	if m != nil {
		return m.Having
	}
	return nil
}

type JoinKeyPb struct {
	Having *expr.NodePb `protobuf:"bytes,1,opt,name=having" json:"having,omitempty"`
}

func (m *JoinKeyPb) Reset()                    { *m = JoinKeyPb{} }
func (m *JoinKeyPb) String() string            { return proto.CompactTextString(m) }
func (*JoinKeyPb) ProtoMessage()               {}
func (*JoinKeyPb) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *JoinKeyPb) GetHaving() *expr.NodePb {
	if m != nil {
		return m.Having
	}
	return nil
}

func init() {
	proto.RegisterType((*PlanPb)(nil), "plan.PlanPb")
	proto.RegisterType((*SelectPb)(nil), "plan.SelectPb")
	proto.RegisterType((*ContextPb)(nil), "plan.ContextPb")
	proto.RegisterType((*SourcePb)(nil), "plan.SourcePb")
	proto.RegisterType((*WherePb)(nil), "plan.WherePb")
	proto.RegisterType((*GroupByPb)(nil), "plan.GroupByPb")
	proto.RegisterType((*HavingPb)(nil), "plan.HavingPb")
	proto.RegisterType((*OrderPb)(nil), "plan.OrderPb")
	proto.RegisterType((*JoinMergePb)(nil), "plan.JoinMergePb")
	proto.RegisterType((*JoinKeyPb)(nil), "plan.JoinKeyPb")
}

func init() { proto.RegisterFile("plan.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 599 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0x55, 0xdc, 0x34, 0xb1, 0x27, 0xf9, 0xfa, 0x95, 0x15, 0x42, 0xab, 0x5e, 0xa0, 0xc8, 0x20,
	0x94, 0x82, 0x64, 0xab, 0x2d, 0xbc, 0x00, 0x08, 0x51, 0x8a, 0x00, 0x6b, 0x2b, 0xc4, 0x25, 0xf2,
	0xcf, 0xd4, 0x76, 0xb5, 0xd9, 0x75, 0xd6, 0x0e, 0xb4, 0x4f, 0xc2, 0x3b, 0xf1, 0x54, 0x68, 0x77,
	0x6d, 0xc7, 0x50, 0x09, 0x35, 0x77, 0x3b, 0x67, 0xce, 0xfc, 0x78, 0xe6, 0x8c, 0x01, 0x2a, 0x1e,
	0x8b, 0xa0, 0x52, 0xb2, 0x91, 0x64, 0xac, 0xdf, 0x47, 0xc7, 0x79, 0xd9, 0x14, 0x9b, 0x24, 0x48,
	0xe5, 0x2a, 0x8c, 0x55, 0x9c, 0x65, 0x52, 0x84, 0x6b, 0x9e, 0xa8, 0x32, 0xcb, 0x31, 0x54, 0xc8,
	0xc3, 0x7a, 0xcd, 0x6d, 0xc0, 0xd1, 0x8b, 0x7f, 0x51, 0xf1, 0xa6, 0x52, 0xa1, 0x90, 0x19, 0x5a,
	0xb2, 0xff, 0x6b, 0x0f, 0x26, 0x11, 0x8f, 0x45, 0x94, 0x90, 0x23, 0x70, 0xab, 0x58, 0xc5, 0x9c,
	0x23, 0xa7, 0xa3, 0xc5, 0x68, 0xe9, 0xb2, 0xde, 0x26, 0xcf, 0x60, 0x52, 0x23, 0xc7, 0xb4, 0xa1,
	0x7b, 0x8b, 0xd1, 0x72, 0x76, 0x7a, 0x10, 0x98, 0x0e, 0x2f, 0x0d, 0x16, 0x25, 0xac, 0xf5, 0x1a,
	0x9e, 0xdc, 0xa8, 0x14, 0xe9, 0xf8, 0x0f, 0x9e, 0xc1, 0x0c, 0xcf, 0xbc, 0xc8, 0x13, 0xd8, 0xff,
	0x51, 0xa0, 0x42, 0xba, 0x6f, 0x68, 0xff, 0x59, 0xda, 0x57, 0x0d, 0x45, 0x09, 0xb3, 0x3e, 0x9d,
	0xac, 0x88, 0xbf, 0x97, 0x22, 0xa7, 0x93, 0x61, 0xb2, 0x73, 0x83, 0xe9, 0x64, 0xd6, 0x4b, 0x8e,
	0x61, 0x9a, 0x2b, 0xb9, 0xa9, 0x5e, 0xdf, 0xd2, 0xa9, 0x21, 0xfe, 0x6f, 0x89, 0xef, 0x2c, 0x18,
	0x25, 0xac, 0xf3, 0xeb, 0xba, 0x52, 0x65, 0xa8, 0xa8, 0x3b, 0xac, 0xfb, 0x59, 0x43, 0xba, 0xae,
	0xf1, 0x91, 0x10, 0xbc, 0x6b, 0x59, 0x8a, 0x8f, 0xa8, 0x72, 0xa4, 0x9e, 0x21, 0x3e, 0xb0, 0xc4,
	0x8b, 0x0e, 0x8e, 0x12, 0xb6, 0xe5, 0xe8, 0x06, 0xb4, 0xf1, 0x01, 0x6f, 0x29, 0x0c, 0x1b, 0xb8,
	0xb0, 0xa0, 0x6e, 0xa0, 0xf5, 0x93, 0x13, 0x80, 0x4a, 0xc9, 0x6b, 0x4c, 0x9b, 0x52, 0x0a, 0x3a,
	0x6b, 0x93, 0x2b, 0xe4, 0x41, 0xd4, 0xc3, 0x51, 0xc2, 0x06, 0x24, 0xb2, 0x04, 0x37, 0x2d, 0x4a,
	0x9e, 0x29, 0x14, 0x74, 0xbe, 0xd8, 0x5b, 0xce, 0x4e, 0xe7, 0x36, 0xbd, 0xdd, 0x1b, 0xeb, 0xbd,
	0xfe, 0x37, 0x70, 0xbb, 0x8d, 0x90, 0x65, 0xbf, 0xb1, 0x91, 0x29, 0x72, 0x68, 0x8a, 0x5c, 0xae,
	0xf9, 0x9d, 0x9d, 0x1d, 0xc3, 0x34, 0x95, 0xa2, 0xc1, 0x9b, 0x86, 0x3a, 0xc3, 0xee, 0xdf, 0x58,
	0x50, 0x77, 0xdf, 0xfa, 0xfd, 0x2f, 0xe0, 0xf5, 0x28, 0x79, 0x04, 0x93, 0x3a, 0x2d, 0x70, 0x15,
	0x9b, 0x0a, 0x1e, 0x6b, 0x2d, 0x72, 0x00, 0x4e, 0x99, 0x99, 0x54, 0x63, 0xe6, 0x94, 0x19, 0x59,
	0xc0, 0xec, 0xaa, 0x14, 0x39, 0xaa, 0x4a, 0x95, 0xc2, 0x0a, 0x68, 0xcc, 0x86, 0x90, 0xff, 0xd3,
	0x01, 0xb7, 0x93, 0x08, 0x79, 0x0e, 0x87, 0x02, 0x31, 0xab, 0xcf, 0xe3, 0xba, 0x88, 0x13, 0x8e,
	0x7a, 0xaa, 0x8e, 0x91, 0xe3, 0x1d, 0x9c, 0x3c, 0x84, 0xfd, 0xab, 0x52, 0xc4, 0xdc, 0x24, 0x75,
	0x99, 0x35, 0xb4, 0x90, 0x53, 0xb9, 0xaa, 0x38, 0x36, 0x56, 0x86, 0x2e, 0xeb, 0x6d, 0x42, 0x60,
	0xac, 0x57, 0x61, 0x74, 0xe7, 0x32, 0xf3, 0x26, 0x8f, 0x01, 0xac, 0x2c, 0xdf, 0xde, 0x60, 0x6a,
	0xb4, 0xe6, 0xb2, 0x01, 0xa2, 0x3f, 0x34, 0xdd, 0xd4, 0x8d, 0x5c, 0x19, 0x79, 0xcd, 0x59, 0x6b,
	0x91, 0x00, 0xbc, 0x7a, 0xcd, 0x6d, 0xe3, 0xad, 0xa0, 0xb6, 0x53, 0xee, 0x14, 0xbf, 0xa5, 0xfc,
	0xb5, 0x7b, 0xef, 0x1e, 0xbb, 0xf7, 0xdf, 0xc3, 0xb4, 0x3d, 0x8a, 0x1d, 0x16, 0xda, 0x4f, 0xc5,
	0x19, 0x4c, 0xc5, 0x7f, 0x05, 0x5e, 0x7f, 0x10, 0xf7, 0x4f, 0xe6, 0xbf, 0x04, 0xb7, 0x3b, 0xb8,
	0x1d, 0xa2, 0xce, 0x60, 0xda, 0x1e, 0xd5, 0x4e, 0x41, 0xb3, 0xc1, 0x81, 0x91, 0xa7, 0xfd, 0xf9,
	0xdb, 0xc0, 0x79, 0xa0, 0x7f, 0x5e, 0xc1, 0x27, 0x99, 0xe1, 0xf6, 0xf8, 0xfd, 0x13, 0xf0, 0xfa,
	0x33, 0xbb, 0x5f, 0x48, 0x32, 0x31, 0xbf, 0xbe, 0xb3, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x3c,
	0xd3, 0x6c, 0xd0, 0x66, 0x05, 0x00, 0x00,
}
